#### Java 中 new 一个对象发生了什么？

答：

*Java* 在 *new* 一个类的对象时，会先查看对象所属的类有没有被加载到内存，如果没有，就会先通过类的权限定类名来加载类。加载并初始化类后，再进行对象的创建工作。

我们假设是第一次使用一个类，这样的话 *new* 一个对象就可以分为两个过程：

1. 加载并初始化类

2. 创建对象

##### 类加载过程

类从被加载到 *JVM* 到卸载出内存，整个生命周期如图所示：

![img](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008eGmZEgy1gnvd7r37bwj30as0wq0uh.jpg&sign=bdbc233a2c9bdfe0cf73b260c2a7ee31bbdcf92bcb9bcc49e6de630b7275166e)

加载 -> 连接(验证 -> 准备 -> 解析) -> 初始化 ->使用 -> 卸载

各个阶段的主要功能为：

- 加载：查找并加载类文件的二进制数据
- 连接：将已经读入内存的类的二进制数据合并到 *JVM* 运行时环境中去，包含如下几个步骤：

- 验证：确保被加载类的正确性
- 准备：为类的**静态变量**分配内存，赋默认值；例如：`public static int a = 1;` 在准备阶段对静态变量 *a* 赋默认值 *0*

- 解析：把常量池中的符号引用转换成直接引用

- 初始化：为类的静态变量赋初始值，这个时候才对静态变量 *a* 赋初始值 *1*



我们可以看到，*Java* 中，**类的静态成员在类加载过程中就已经被加载到内存中了！**



那么类是如何被加载的呢？答案是：类加载器



##### 类加载器

*Java* 虚拟机自带的加载器包括如下几种：( *JDK9* 开始)



- 启动类加载器(*BootstrapClassLoader*)

- 平台类加载器(*PlatformClassLoader*)

- 应用程序类加载器(*AppClassLoader*)



*JDK8* 虚拟机自带的加载器：



- *BootstrapClassLoader*

- *ExtensionClassLoader*

- *AppClassLoader*



除了虚拟机自带的类加载器外，用户也可以自定义类加载器。



##### 类加载器之间的关系

- *UserClassLoader* (用户自定义类加载器)的父级为 *AppClassLoader*

- *AppClassLoader* 的父级为 *PlatformClassLoader*

- *PlatformClassLoader* 的父级为 *BootstrapClassLoader*

关系图如下所示：

![img](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Ftva1.sinaimg.cn%2Flarge%2F008eGmZEgy1gnvdkoot0nj31340s6jut.jpg&sign=29598ade0ce44a13f473f3c6fa8f0d620f47ad945d6b30889530769ef8745ec1)

##### 双亲委派模型

*JVM* 中的 *ClassLoader* 采用双亲委派模型的方式加载类：

那么什么是双亲委派模型呢？

双亲委托模型就是：如果一个类加载器（*ClassLoader*）收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需要加载的类）时，子加载器才会尝试自己去加载。

使用双亲委托机制的好处是：能够有效确保一个类的全局唯一性，当程序中出现多个限定名相同的类时，类加载器在执行加载时，始终只会加载其中的某一个类。

##### 创建对象

介绍了类加载的过程后，我们就可以真正地创建这个类的对象了。



创建对象包括几个过程；



1. 在堆区中分配对象所需的内存
   分配的内存包括本类和父类的所有实例变量，但不包括任何静态变量

2. 对所有实例变量赋默认值
   将方法区内对实例变量的定义拷贝一份到堆区，然后赋默认值，譬如整型的默认值为 *0*，引用类型的默认值为 *null*

3. 执行实例初始化代码
   初始化顺序是先初始化父类再初始化子类，初始化时先执行实例代码块然后是构造方法